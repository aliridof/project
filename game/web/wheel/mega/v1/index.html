<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Mega Wheel Streak Tracker v4</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 900px;
      margin: 20px auto;
      padding: 0 15px;
      background: #f9f9f9;
    }
    h1, h2, h3 { color: #333; }
    .container { margin-bottom: 20px; }
    .input-group {
      display: flex;
      gap: 10px;
      margin: 10px 0;
      flex-wrap: wrap;
      align-items: center;
    }
    input, button, select {
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    button {
      background: #4A90E2;
      color: white;
      cursor: pointer;
    }
    button:hover { opacity: 0.9; }
    .undo-btn {
      background: #f39c12;
    }
    .number-btn {
      background: var(--color);
      color: black;
      font-weight: bold;
    }
    .streak-item, .history-item, .gap-item {
      display: flex;
      justify-content: space-between;
      padding: 8px;
      margin: 4px 0;
      background: #fff;
      border-left: 4px solid var(--color);
    }
    .error { color: red; margin-top: 5px; }
    .analytics, .gap-analysis { 
      background: #eef; 
      padding: 10px; 
      border-radius: 4px; 
      margin-top: 15px; 
    }
    .history-list, .streak-history-list, .gap-list {
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid #ddd;
      padding: 8px;
      margin-top: 8px;
    }
    .section { border-top: 1px solid #eee; padding-top: 20px; }
  </style>
</head>
<body>
  <h1>Mega Wheel Streak Tracker v4</h1>
  <!-- Input Section -->
  <div class="container">
    <h2>Input Winning Numbers</h2>
    <div class="input-group">
      <input type="text" id="textInput" placeholder="e.g., 5,10,15 or 5 10 15" />
      <button onclick="processTextInput()">Add</button>
      <button class="undo-btn" onclick="undoLastSpin()">Undo Last Spin</button>
    </div>
    <div class="input-group" id="quickButtons"></div>
    <div class="input-group">
      <label>Streak Threshold: <input type="number" id="thresholdInput" min="1" max="100" /></label>
      <button onclick="updateThreshold()">Update</button>
    </div>
    <div id="errorMessage" class="error"></div>
  </div>

  <!-- 1. Analytics -->
  <div class="container analytics">
    <h3>Analytics</h3>
    <div id="analyticsOutput"></div>
  </div>

  <!-- 2. Recent History (with color) -->
  <div class="container">
    <h3>Recent History (max 200)</h3>
    <div id="historyList" class="history-list"></div>
  </div>

  <!-- 3. Streak Happening -->
  <div class="container">
    <h2>Streak Happening (≥ Threshold)</h2>
    <div id="streakHappeningList"></div>
    <div>Last Updated: <span id="lastUpdated"></span></div>
  </div>

  <!-- 4. Completed Streaks History -->
  <div class="container section">
    <h3>Completed Streaks History</h3>
    <div class="input-group">
      <label>Show streaks ≥: <input type="number" id="streakFilterInput" min="1" value="1" /></label>
      <button onclick="renderStreakHistory()">Filter</button>
    </div>
    <div id="streakHistoryList" class="streak-history-list"></div>
  </div>

  <!-- 5. Gap & Time Interval Analysis -->
  <div class="container analytics gap-analysis">
    <h3>Gap & Time Interval Analysis</h3>
    <div id="gapAnalysisList" class="gap-list"></div>
  </div>

  <button onclick="resetData()" style="background:#e74c3c">Reset All Data</button>

  <script>
    // =============== DATA MODEL ===============
    const megaWheelNumbers = [
      { number: 1, segments: 20, color: "#FDEEC9" },
      { number: 2, segments: 13, color: "#F5A623" },
      { number: 5, segments: 7, color: "#4A90E2" },
      { number: 8, segments: 4, color: "#9B51E0" },
      { number: 10, segments: 4, color: "#F25C3B" },
      { number: 15, segments: 2, color: "#F2994A" },
      { number: 20, segments: 2, color: "#6FCF97" },
      { number: 30, segments: 1, color: "#6C5CE7" },
      { number: 40, segments: 1, color: "#E0BBFF" }
    ];
    const VALID_NUMBERS = megaWheelNumbers.map(n => n.number);
    const MAX_HISTORY = 200;
    const MAX_STREAK_HISTORY = 500;

    // =============== STATE ===============
    let streakData = {};
    let historyData = [];
    let streakHistory = []; // { number, streakLength, timeIntervalSec, endedAt }
    let threshold = 10;
    let undoStack = [];

    // =============== INIT ===============
    function init() {
      const savedStreak = localStorage.getItem('megaWheelStreakData');
      const savedHistory = localStorage.getItem('megaWheelHistoryData');
      const savedStreakHistory = localStorage.getItem('megaWheelStreakHistory');
      const savedThreshold = localStorage.getItem('megaWheelThreshold');
      
      if (savedStreak) streakData = JSON.parse(savedStreak);
      if (savedHistory) historyData = JSON.parse(savedHistory);
      if (savedStreakHistory) streakHistory = JSON.parse(savedStreakHistory);
      if (savedThreshold) threshold = parseInt(savedThreshold) || 10;

      VALID_NUMBERS.forEach(num => {
        if (!streakData[num]) {
          streakData[num] = { 
            streak: 0, 
            lastAppearance: null, 
            lastTimestamp: null,
            lastUpdated: new Date().toISOString() 
          };
        }
      });

      document.getElementById('thresholdInput').value = threshold;
      renderQuickButtons();
      updateDisplay();
    }

    function renderQuickButtons() {
      const container = document.getElementById('quickButtons');
      container.innerHTML = '';
      VALID_NUMBERS.forEach(num => {
        const btn = document.createElement('button');
        const color = megaWheelNumbers.find(n => n.number === num).color;
        btn.className = 'number-btn';
        btn.style.setProperty('--color', color);
        btn.textContent = num;
        btn.onclick = () => addWinningNumbers([num]);
        container.appendChild(btn);
      });
    }

    // =============== INPUT PROCESSING ===============
    function parseInput(input) {
      if (!input) return { valid: [], invalid: [] };
      const cleaned = input.replace(/,/g, ' ').trim();
      const tokens = cleaned.split(/\s+/).filter(t => t !== '');
      const nums = tokens.map(t => parseInt(t, 10)).filter(n => !isNaN(n));
      const valid = [...new Set(nums.filter(n => VALID_NUMBERS.includes(n)))]; // ✅ DEDUPLIKASI
      const invalid = nums.filter(n => !VALID_NUMBERS.includes(n));
      return { valid, invalid };
    }

    function processTextInput() {
      const input = document.getElementById('textInput').value;
      const { valid, invalid } = parseInput(input);
      if (invalid.length > 0) {
        showError(`Invalid numbers: ${invalid.join(', ')}. Valid: ${VALID_NUMBERS.join(', ')}`);
        return;
      }
      if (valid.length === 0) {
        showError('No valid numbers found.');
        return;
      }
      addWinningNumbers(valid);
      document.getElementById('textInput').value = '';
      clearError();
    }

    function showError(msg) {
      document.getElementById('errorMessage').textContent = msg;
    }
    function clearError() {
      document.getElementById('errorMessage').textContent = '';
    }

    // =============== STREAK & TIME LOGIC WITH UNDO ===============
    function saveStateForUndo() {
      undoStack.push({
        streakData: JSON.parse(JSON.stringify(streakData)),
        historyData: JSON.parse(JSON.stringify(historyData)),
        streakHistory: JSON.parse(JSON.stringify(streakHistory))
      });
      if (undoStack.length > 50) undoStack.shift();
    }

    function addWinningNumbers(winningNumbers) {
      saveStateForUndo();

      const now = new Date();
      const nowIso = now.toISOString();

      VALID_NUMBERS.forEach(num => {
        if (winningNumbers.includes(num)) {
          const lastTime = streakData[num].lastTimestamp ? new Date(streakData[num].lastTimestamp) : null;
          let timeIntervalSec = null;

          if (streakData[num].streak >= 1 && lastTime) {
            timeIntervalSec = Math.round((now - lastTime) / 1000);
            streakHistory.unshift({
              number: num,
              streakLength: streakData[num].streak,
              timeIntervalSec: timeIntervalSec,
              endedAt: nowIso
            });
            if (streakHistory.length > MAX_STREAK_HISTORY) {
              streakHistory = streakHistory.slice(0, MAX_STREAK_HISTORY);
            }
          }

          streakData[num].streak = 0;
          streakData[num].lastAppearance = nowIso;
          streakData[num].lastTimestamp = nowIso;
        } else {
          streakData[num].streak += 1;
        }
        streakData[num].lastUpdated = nowIso;
      });

      winningNumbers.forEach(num => {
        historyData.unshift({ number: num, timestamp: nowIso });
      });
      if (historyData.length > MAX_HISTORY) {
        historyData = historyData.slice(0, MAX_HISTORY);
      }

      saveToStorage();
      updateDisplay();
    }

    function undoLastSpin() {
      if (undoStack.length === 0 || historyData.length === 0) {
        alert('No action to undo.');
        return;
      }
      const lastState = undoStack.pop();
      streakData = lastState.streakData;
      historyData = lastState.historyData;
      streakHistory = lastState.streakHistory;
      saveToStorage();
      updateDisplay();
    }

    // =============== THRESHOLD ===============
    function updateThreshold() {
      const val = parseInt(document.getElementById('thresholdInput').value);
      if (isNaN(val) || val < 1 || val > 100) {
        showError('Threshold must be between 1 and 100.');
        return;
      }
      threshold = val;
      localStorage.setItem('megaWheelThreshold', threshold);
      clearError();
      updateDisplay();
    }

    // =============== DISPLAY ===============
    function updateDisplay() {
      renderStreakHappening();
      renderAnalytics();
      renderGapAnalysis();
      renderHistory();
      renderStreakHistory();
      document.getElementById('lastUpdated').textContent = new Date().toLocaleString();
    }

    function formatDate(dateStr) {
      if (!dateStr) return 'Never';
      const d = new Date(dateStr);
      return isNaN(d.getTime()) ? 'Invalid Date' : d.toLocaleString();
    }

    function formatTime(seconds) {
      if (seconds === null || seconds === undefined) return '–';
      if (seconds < 60) return `${seconds}s`;
      if (seconds < 3600) return `${Math.floor(seconds / 60)}m ${seconds % 60}s`;
      return `${Math.floor(seconds / 3600)}h ${Math.floor((seconds % 3600) / 60)}m`;
    }

    function renderStreakHappening() {
      const list = document.getElementById('streakHappeningList');
      const happening = Object.entries(streakData)
        .filter(([num, data]) => data.streak >= threshold)
        .sort((a, b) => b[1].streak - a[1].streak);
      if (happening.length === 0) {
        list.innerHTML = '<p>No numbers meet the threshold.</p>';
        return;
      }
      list.innerHTML = happening.map(([num, data]) => {
        const color = megaWheelNumbers.find(n => n.number === parseInt(num)).color;
        const last = formatDate(data.lastAppearance);
        return `
          <div class="streak-item" style="--color:${color}">
            <span><strong>${num}</strong> — Streak: ${data.streak}</span>
            <span>Last: ${last}</span>
          </div>
        `;
      }).join('');
    }

    function renderAnalytics() {
      const totalSpins = historyData.length;
      const coldest = Object.entries(streakData).reduce((a, b) => a[1].streak > b[1].streak ? a : b);
      const freq = {};
      historyData.forEach(h => {
        freq[h.number] = (freq[h.number] || 0) + 1;
      });
      const hottest = Object.entries(freq).length > 0
        ? Object.entries(freq).reduce((a, b) => a[1] > b[1] ? a : b)
        : ['-', 0];
      document.getElementById('analyticsOutput').innerHTML = `
        <p><strong>Total Spins:</strong> ${totalSpins}</p>
        <p><strong>Coldest Number:</strong> ${coldest[0]} (Streak: ${coldest[1].streak})</p>
        <p><strong>Hottest Number:</strong> ${hottest[0]} (Appeared ${hottest[1]} times)</p>
        <p><strong>Completed Streaks:</strong> ${streakHistory.length}</p>
      `;
    }

    // =============== GAP & TIME ANALYSIS ===============
    function calculateGapStats(number) {
      const gaps = streakHistory
        .filter(s => s.number === number)
        .map(s => s.streakLength);

      const times = streakHistory
        .filter(s => s.number === number)
        .map(s => s.timeIntervalSec)
        .filter(t => t !== null);

      const currentStreak = streakData[number].streak;
      const count = gaps.length;

      if (count === 0) {
        return { count, currentStreak };
      }

      const sumGaps = gaps.reduce((a, b) => a + b, 0);
      const sumTimes = times.reduce((a, b) => a + b, 0);

      return {
        count,
        currentStreak,
        avgGap: parseFloat((sumGaps / count).toFixed(1)),
        avgTime: times.length > 0 ? parseFloat((sumTimes / times.length).toFixed(1)) : null,
        maxGap: Math.max(...gaps),
        minGap: Math.min(...gaps),
        maxTime: times.length > 0 ? Math.max(...times) : null,
        minTime: times.length > 0 ? Math.min(...times) : null
      };
    }

    function renderGapAnalysis() {
      const container = document.getElementById('gapAnalysisList');
      container.innerHTML = VALID_NUMBERS.map(num => {
        const stats = calculateGapStats(num);
        if (stats.count === 0 && stats.currentStreak === 0) return '';

        const color = megaWheelNumbers.find(n => n.number === num).color;
        const avgGap = stats.avgGap ?? '–';
        const avgTime = stats.avgTime ? formatTime(stats.avgTime) : '–';
        const maxGap = stats.maxGap ?? '–';
        const currentTime = streakData[num].lastTimestamp 
          ? formatTime(Math.round((new Date() - new Date(streakData[num].lastTimestamp)) / 1000))
          : '–';

        return `
          <div class="gap-item" style="--color:${color}">
            <span><strong>${num}</strong></span>
            <span>
              Avg Gap: ${avgGap} | 
              Avg Time: ${avgTime} | 
              Max Gap: ${maxGap} | 
              Current: ${stats.currentStreak} spins (${currentTime})
            </span>
          </div>
        `;
      }).join('');
    }

    function renderHistory() {
      const list = document.getElementById('historyList');
      if (historyData.length === 0) {
        list.innerHTML = '<p>No history yet.</p>';
        return;
      }
      list.innerHTML = historyData.map(h => {
        const color = megaWheelNumbers.find(n => n.number === h.number).color;
        return `
          <div class="history-item" style="--color:${color}">
            <span><strong>${h.number}</strong></span>
            <span>${formatDate(h.timestamp)}</span>
          </div>
        `;
      }).join('');
    }

    function renderStreakHistory() {
      const filterVal = parseInt(document.getElementById('streakFilterInput').value) || 1;
      const list = document.getElementById('streakHistoryList');
      const filtered = streakHistory
        .filter(s => s.streakLength >= filterVal)
        .slice(0, 100);
      if (filtered.length === 0) {
        list.innerHTML = '<p>No completed streaks match the filter.</p>';
        return;
      }
      list.innerHTML = filtered.map(s => {
        const color = megaWheelNumbers.find(n => n.number === s.number).color;
        return `
          <div class="streak-item" style="--color:${color}">
            <span><strong>${s.number}</strong> — Streak: ${s.streakLength}</span>
            <span>
              Time: ${formatTime(s.timeIntervalSec)} | 
              Ended: ${formatDate(s.endedAt)}
            </span>
          </div>
        `;
      }).join('');
    }

    // =============== PERSISTENCE ===============
    function saveToStorage() {
      localStorage.setItem('megaWheelStreakData', JSON.stringify(streakData));
      localStorage.setItem('megaWheelHistoryData', JSON.stringify(historyData));
      localStorage.setItem('megaWheelStreakHistory', JSON.stringify(streakHistory));
    }

    function resetData() {
      if (!confirm('Reset all data? This cannot be undone.')) return;
      streakData = {};
      historyData = [];
      streakHistory = [];
      undoStack = [];
      VALID_NUMBERS.forEach(num => {
        streakData[num] = { 
          streak: 0, 
          lastAppearance: null, 
          lastTimestamp: null, 
          lastUpdated: new Date().toISOString() 
        };
      });
      saveToStorage();
      updateDisplay();
    }

    // =============== START ===============
    window.onload = init;
  </script>
</body>
</html>